---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---
**Fonction et library**
```{r fonction, warning=FALSE, message=FALSE}
library(reshape)
library(dplyr)
library(splitstackshape)
options("scipen"=100)


###Cette fonction permet de savoir si une colonne ou un ensemble de 
###colonne est une primaire ou non d'une certaine table
###La fonction prend en argument:
###-la table en question (df)
###-la, les colonnes, ou l'ensemble de colonne que l'on veut tester
check_possible_primary_key<-
  function(df, ...){
   ###On sélectionne les colonne que l'on veut tester
   x<-select(df, ...)
   ###Si le nombre de ligne après avoir supprimé les doublons est le
   ###même que celui de la table de base on retourne oui sinon non
   if (nrow(df) == nrow(df[!duplicated(x),])){
     return(TRUE)
   }else return(FALSE)
  }
```

**Question 15**
```{r 14, warning=FALSE, message=FALSE}
population<-
  read.csv("pop20122018.csv", encoding = "UTF-8")%>%
  select(pays = Zone, code_pays = Code.zone,
         année = Année, population = Valeur)

population$population<-unlist(population$population)%>%
  as.vector()%>%as.numeric()*1000
  
write.csv(population, "population.csv", row.names = FALSE)

###On test des colonnes pour savoir si ce sont bien des clé candidates
check_possible_primary_key(population, code_pays, année)

###La fonction retourne TRUE donc notre clé est une clé candidate
cat("(code_pays, année) est une clé primaire pertinente pour cette",  
    "table")
```
<br>
<br>
**Question 16**
```{r 15, warning=FALSE, message=FALSE}
veg2012<-read.csv("veg2012.csv", encoding = "UTF-8")
veg2013<-read.csv("veg2013.csv", encoding = "UTF-8")
veg2014<-read.csv("veg2014.csv", encoding = "UTF-8")
veg2015<-read.csv("veg2015.csv", encoding = "UTF-8")
veg2016<-read.csv("veg2016.csv", encoding = "UTF-8")
veg2017<-read.csv("veg2017.csv", encoding = "UTF-8")

ani20122013<-read.csv("ani20122013.csv", encoding = "UTF-8")
ani20142017<-read.csv("ani20142017.csv", encoding = "UTF-8")

ani<-rbind(ani20122013, ani20142017)
veg<-rbind(veg2012, veg2013, veg2014, veg2015,
           veg2016, veg2017)

veg$origin <- "végétal"
ani$origin<- "animal"

produit20122017<-rbind(ani, veg)%>%filter(Symbole != "A")

dispo_alim<-
  filter(produit20122017, 
         Code.Élément %in% c("5142","664","674","684"))%>%
  select(pays = Zone, code_pays = Code.zone,
         produit = Produit, code_produit = Code.Produit,
         année = Année, origin, Élément, Valeur)%>%
  cast(
    pays+code_pays+année+origin+produit+code_produit~Élément)%>%
  select(1:3,5,6,4,10,7,9,8)

dispo_alim<-tidyr::drop_na(dispo_alim)

colnames(dispo_alim)<-
  c("pays", "code_pays", "année", "produit", "code_produit",
    "origin", "dispo_alim_tonnes", "dispo_alim_kcal_p_j",
    "dispo_prot", "dispo_mat_gr")

dispo_alim$dispo_alim_tonnes<-
  dispo_alim$dispo_alim_tonnes*1000

write.csv(dispo_alim, "dispo_alim.csv",row.names = FALSE)

###On test des colonnes pour savoir si ce sont bien des clé candidates
check_possible_primary_key(dispo_alim, code_pays, année, code_produit)

###La fonction retourne TRUE donc notre clé est une clé candidate
cat("(code_pays, année, code_produit) est une clé primaire pertinente",      "pour cette table")
```
<br>
<br>
**Question 17**
```{r 16, warning=FALSE, message=FALSE}
equilibre_prod<-
  filter(produit20122017,
         Code.Élément %in% 
           c("5142","5154","5131","5123","5527","5521","5301"))%>%
  select(pays=Zone,code_pays=Code.zone,année=Année,produit=Produit,
         code_produit=Code.Produit, Élément, Valeur)%>%
  cast(
    pays+code_pays+année+produit+code_produit~Élément)%>%
  select(1:5,8,6,11,10,12,9,7)

equilibre_prod<-tidyr::drop_na(equilibre_prod)

colnames(equilibre_prod)<-
  c("pays", "code_pays", "année", "produit", "code_produit",
    "dispo_int", "alim_ani", "semences", "pertes", "transfo",
    "nourriture", "autres_utilisations")

write.csv(equilibre_prod, "equilibre_prod.csv", row.names = FALSE)

###On test des colonnes pour savoir si ce sont bien des clé candidates
check_possible_primary_key(equilibre_prod, code_pays, année,
                           code_produit)

###La fonction retourne TRUE donc notre clé est une clé candidate
cat("(code_pays, année, code_produit) est une clé primaire pertinente",      "pour cette table")
  
```
<br>
<br>
**Question 18**
```{r 17, warning=FALSE, message=FALSE}
###-On charge le tableau du nombre de personne sous-alimenté
###par pays(On enlève la chine pour ne compter personne en double)
sous_nutrition<-read.csv("sousali.csv", encoding = "UTF-8")%>%
  filter(Code.zone != "351", Symbole == "F", Valeur != "<0.1")%>%
  concat.split(split.col = "Année", sep = "-", drop = TRUE)

sous_nutrition$année <-
  apply(select(sous_nutrition, Année_1, Année_2), 1, mean)
                              
sous_nutrition<-
  select(sous_nutrition, pays = Zone, code_pays = Code.zone, 
         année, nb_personnes = Valeur)

sous_nutrition$nb_personnes<-
  unlist(sous_nutrition$nb_personnes)%>%
  as.vector()%>%
  as.numeric()*10^6

write.csv(sous_nutrition, "sous_nutrition.csv", row.names = FALSE)

###On test des colonnes pour savoir si ce sont bien des clé candidates
check_possible_primary_key(sous_nutrition, code_pays, année)

###La fonction retourne TRUE donc notre clé est une clé candidate
cat("(code_pays, année) est une clé primaire pertinente",      
    "pour cette table")
```

